-- Create the table for iceberg charts
CREATE TABLE iceberg_charts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  category TEXT
);

-- Create the table for iceberg layers
CREATE TABLE iceberg_layers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chart_id BIGINT NOT NULL REFERENCES iceberg_charts(id) ON DELETE CASCADE,
  layer_name TEXT NOT NULL,
  layer_order INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the table for iceberg entries
CREATE TABLE iceberg_entries (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  layer_id BIGINT NOT NULL REFERENCES iceberg_layers(id) ON DELETE CASCADE,
  entry_text TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable Row Level Security (RLS) for all tables
-- This is a good practice, but for this app to work out-of-the-box
-- with the public anon key, we will create policies that allow public access.
-- For a production app, you would want to restrict this more.
ALTER TABLE iceberg_charts ENABLE ROW LEVEL SECURITY;
ALTER TABLE iceberg_layers ENABLE ROW LEVEL SECURITY;
ALTER TABLE iceberg_entries ENABLE ROW LEVEL SECURITY;

-- Create policies to allow public read access
CREATE POLICY "Public read access for charts" ON iceberg_charts FOR SELECT USING (true);
CREATE POLICY "Public read access for layers" ON iceberg_layers FOR SELECT USING (true);
CREATE POLICY "Public read access for entries" ON iceberg_entries FOR SELECT USING (true);

-- Create policies to allow all actions (insert, update, delete)
-- In a real application, you would secure this behind user authentication.
CREATE POLICY "Allow all actions for charts" ON iceberg_charts FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all actions for layers" ON iceberg_layers FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all actions for entries" ON iceberg_entries FOR ALL USING (true) WITH CHECK (true);
